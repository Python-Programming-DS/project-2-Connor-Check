# -*- coding: utf-8 -*-
"""CC_Project2_PartC.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TI9cRfEuYWIBpRyaRG7sf7ekckOPZ4Sj
"""

import pandas as pd
from sklearn.model_selection import train_test_split, GridSearchCV, RandomizedSearchCV
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report
from sklearn.ensemble import RandomForestClassifier

data = pd.read_csv("tictac_single.txt", header=None, delim_whitespace=True)


X = data.iloc[:, :-1]
y = data.iloc[:, -1]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

y_pred = model.predict(X_test)
print("Test accuracy:", accuracy_score(y_test, y_pred))

class Board:
    def __init__(self):
        self.grid = [[" " for _ in range(3)] for _ in range(3)]

    def resetBoard(self):
        self.grid = [[" " for _ in range(3)] for _ in range(3)]

    def printBoard(self):
        print(".................")
        print("|R\\C| 0 | 1 | 2 |")
        print("-----------------")
        for i, row in enumerate(self.grid):
            print(f"| {i}", end=" | ")
            print(" | ".join(row), end=" |\n")
            print("-----------------")
        print("")


class Game:
    def __init__(self):
        self.board = Board()
        self.turn = 'X'

    def switchPlayer(self):
        if self.turn == 'X':
          self.turn = 'O'
        else:
          self.turn = 'X'

    def validateEntry(self, row, col):
        if 0 <= row < 3 and 0 <= col < 3:
            if self.board.grid[row][col] == " ":
                return True
            else:
                print("That cell is already taken.")
                print("Please make another selection.")
                return False
        else:
            print("Invalid entry: try again.")
            print("Row & column numbers must be either 0, 1, or 2.")
            return False

    def checkFull(self):
        for row in self.board.grid:
            if " " in row:
                return False
        return True

    def checkWin(self, player=None):
        b = self.board.grid
        if player:
            t = player
        else:
          t = self.turn

        # Rows
        for row in range(3):
            if all(b[row][col] == t for col in range(3)):
                return True

        # Columns
        for col in range(3):
            if all(b[row][col] == t for row in range(3)):
                return True

        # Diagonals
        if all(b[i][i] == t for i in range(3)) or all(b[i][2 - i] == t for i in range(3)):
            return True

        return False

    def checkEnd(self):
        if self.checkWin():
            print(f"{self.turn} IS THE WINNER!!!")
            self.board.printBoard()
            return True
        elif self.checkFull():
            print("DRAW! NOBODY WINS!")
            self.board.printBoard()
            return True
        return False

    def getMove(self):
        while True:
            move = input("Please enter row number and column number separated by a comma. ")
            if move.lower() == 'reset':
                return 'reset', 'reset'

            coords = move.split(",")
            if len(coords) != 2:
                print("Invalid input format. Please enter as 'row,col' (e.g., 0,1).")
                continue

            row_str, col_str = coords[0], coords[1]

            if not (row_str.isdigit() and col_str.isdigit()):
                print("Invalid input: row and column must be numbers.")
                continue

            row, col = int(row_str), int(col_str)
            print(f"You have entered row #{row}")
            print(f"\t  and column #{col}")
            return row, col



    def getBestMove(self, model):
        line_board = []
        for i in range(3):
            for j in range(3):
              if self.board.grid[i][j] == "X":
                line_board.append(1)
              elif self.board.grid[i][j] == "O":
                line_board.append(-1)
              else:
                line_board.append(0)
        move = int(model.predict([line_board])[0])
        row, col = divmod(move, 3)
        return row,col

    def playGame(self):
        while True:
            if self.board.grid == [[" ", " ", " "], [" ", " ", " "], [" ", " ", " "]]:
                print("\nNew Game: You are X, going first.")
            self.board.printBoard()

            if self.turn == "X":
              print(f"{self.turn}'s turn.")
              print(f"Where do you want your {self.turn} placed?")
              row, col = self.getMove()

              if row == 'reset':
                  print("Game has been reset.")
                  self.board.resetBoard()
                  self.turn = "X"
                  continue

              if self.validateEntry(row, col):
                  print("Thank you for your selection.")
                  self.board.grid[row][col] = self.turn

            else:
                print("Computer's turn.")
                move = self.getBestMove(model)
                if move:
                    row, col = move
                    self.board.grid[row][col] = "O"
                    print(f"Computer placed O at ({row}, {col})")

            if self.checkEnd():
                    again = input("Play again? (y/n): ").lower()
                    if again == 'y':
                        self.board.resetBoard()
                        self.turn = "X"
                    else:
                        print("Thank you for playing!")
                        break
            else:
                self.switchPlayer()


if __name__ == "__main__":
    game = Game()
    game.playGame()